// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 { function transfer(address to, uint256 amount) external returns (bool); function transferFrom(address from, address to, uint256 amount) external returns (bool); }

contract JobEscrow { IERC20 public usdcToken; address public owner; struct Job { address employer; address freelancer; uint256 weeklyAmount; uint256 currentWeek; bool isActive; uint256 createdAt; } struct Timesheet { uint256 hoursWorked; string description; bool approved; uint256 submittedAt; uint256 approvedAt; } mapping(string => Job) public jobs; mapping(string => mapping(uint256 => Timesheet)) public timesheets; mapping(string => mapping(uint256 => uint256)) public weeklyFunding; event JobCreated(string indexed jobId, address indexed employer, address indexed freelancer, uint256 weeklyAmount, uint256 timestamp); event WeekFunded(string indexed jobId, uint256 weekNumber, uint256 amount, uint256 timestamp); event TimesheetApproved(string indexed jobId, uint256 weekNumber, uint256 amount, uint256 timestamp); event PaymentReleased(string indexed jobId, uint256 weekNumber, address indexed freelancer, uint256 amount, uint256 timestamp); constructor(address _usdcToken) { usdcToken = IERC20(_usdcToken); owner = msg.sender; } function createJob(string memory jobId, address freelancer, uint256 weeklyAmount) external { require(bytes(jobId).length > 0); require(freelancer != address(0)); require(weeklyAmount > 0); require(jobs[jobId].employer == address(0)); jobs[jobId] = Job(msg.sender, freelancer, weeklyAmount, 0, true, block.timestamp); emit JobCreated(jobId, msg.sender, freelancer, weeklyAmount, block.timestamp); } function fundWeek(string memory jobId, uint256 weekNumber) external { Job storage job = jobs[jobId]; require(job.employer == msg.sender); require(job.isActive); require(weeklyFunding[jobId][weekNumber] == 0); require(usdcToken.transferFrom(msg.sender, address(this), job.weeklyAmount)); weeklyFunding[jobId][weekNumber] = job.weeklyAmount; emit WeekFunded(jobId, weekNumber, job.weeklyAmount, block.timestamp); } function approveTimesheet(string memory jobId, uint256 weekNumber) external { Job storage job = jobs[jobId]; require(job.employer == msg.sender); require(weeklyFunding[jobId][weekNumber] > 0); uint256 amount = weeklyFunding[jobId][weekNumber]; weeklyFunding[jobId][weekNumber] = 0; require(usdcToken.transfer(job.freelancer, amount)); emit TimesheetApproved(jobId, weekNumber, amount, block.timestamp); emit PaymentReleased(jobId, weekNumber, job.freelancer, amount, block.timestamp); } function getJobStatus(string memory jobId) external view returns (address, address, uint256, uint256, bool, uint256) { Job memory job = jobs[jobId]; return (job.employer, job.freelancer, job.weeklyAmount, job.currentWeek, job.isActive, job.createdAt); } function isWeekFunded(string memory jobId, uint256 weekNumber) external view returns (bool, uint256) { uint256 amount = weeklyFunding[jobId][weekNumber]; return (amount > 0, amount); } }